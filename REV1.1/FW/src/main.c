/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.0.1   2018-12-22

The MIT License (MIT)
Copyright (c) 2018 STMicroelectronics

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************
*/

/* Includes */
#include "stm32f0xx.h"
#include <stdbool.h>

#include "clock.h"
#include "gpio.h"
#include "timer.h"
#include "adc.h"

#include "ElectronicLoadDrv.h"
#include "SevenSegmentDrv.h"
#include "RotaryEncoderDrv.h"






/*
 * 		DISPLAY VARIABLES
 */

// Numbers
uint16_t DisplayNumber = 0u;

// Strings
DisplayCharTypeDef DisplayCharsCP[4] 	= { NONE_c, NONE_c, C_c, P_c};
DisplayCharTypeDef DisplayCharsCC[4] 	= { NONE_c, NONE_c, C_c, C_c};
DisplayCharTypeDef DisplayCharsCR[4] 	= { NONE_c, NONE_c, C_c, R_c};
DisplayCharTypeDef DisplayCharsERR[4] 	= { NONE_c, E_c, 	R_c, R_c};
//DisplayCharTypeDef SEL[4] 	= { NONE_c, S_c, 	E_c, L_c};

// Display string selection
DisplayCharTypeDef *DisplayStr;

// Display active digit
//volatile uint8_t DisplayDigit = 0u;
uint8_t DisplayDigit = 0u;

// Display refresh numbers
float displayRefreshTime = 0.0f;

// Display decimal point
bool displayDecPoint = true;

// Display timer flag
volatile bool DisplayTim_f = false;

// Display menus by modes
void DisplayMenuMode(ElModeTypeDef*);

// NOTE: powered by encoder timer
#define DISPLAY_REFRESH_TIMEOUT		( float )			( 1.0f )	// s


/*
 * 	Leds
 */
void LedsMenuMode(void);


/*
 * 	Rotary encoder
 */
RotaryEncoderTypedef RotaryEncoder;

// RE timer overflow flag
volatile uint8_t RETim_f = false;


/*
 * 	ELECTRONIC LOAD OPERATION MODES
 */

// Definition of constant current mode
ElModeTypeDef CCMode = { 	.mode			= CC_mode,
							.minimum		= CUR_min,
							.maximum		= CUR_max,
							.resolution		= CUR_res,
							.actValue		= &( GetCurrent ),
							.display_chars	=  ( DisplayCharTypeDef* ) &DisplayCharsCC
						};

// Definition of constant power mode
ElModeTypeDef CPMode = { 	.mode		= CP_mode,
							.minimum	= POW_min,
							.maximum	= POW_max,
							.resolution	= POW_res,
							.actValue	= &( GetPower ),
							.display_chars	=  ( DisplayCharTypeDef* ) &DisplayCharsCP
						};

// Definition of constant resistance mode
ElModeTypeDef CRMode = { 	.mode		= CR_mode,
							.minimum	= RES_min,
							.maximum	= RES_max,
							.resolution	= RES_res,
							.actValue	= &( GetResistance ),
							.display_chars	=  ( DisplayCharTypeDef* ) &DisplayCharsCR
						};


// Electornic load health
ElectronicLoadHealtTypeDef ElHealth;

// Reference current, power and resistance
float setPoint = 0.0f;



/*
 * 	BUTTON VARIABLE
 */
volatile uint8_t buttonPressed_f = false;
float buttonTimeoutTime = 0.0f;


/*
 *  MENUS
 */
typedef enum{
	MAIN_menu		= ( uint8_t ) ( 0x03u ),
	CC_menu			= ( uint8_t ) ( 0x00u ),
	CP_menu			= ( uint8_t ) ( 0x01u ),
	CR_menu			= ( uint8_t ) ( 0x02u )
}MenuTypeDef;

// Electronic load menu options
MenuTypeDef menuState = MAIN_menu;


// Return to main menu
// Clears some variables
void ReturnToMainMenu(void);

// First entry to menu
volatile bool menuFirstEntry = false;



/**
**===========================================================================
**
**  Abstract: main program
**
**===========================================================================
*/
int main(void)
{

	// Initialize system
	SysClockInit();
	SysTickInit();
	GpioInit();
	DisplayTimerInit();
	CurrentReferenceInit();
	RotaryEncoderInit();
	ADCInit();

	// Electronic modes
	ElModeTypeDef ElMode;


	// Main loop
	while(1){


		/*
		 * 	MAIN MENU FLOW
		 */
		if ( menuState == MAIN_menu ){

			// Chose operation mode
			switch ( RotaryEncoder.cnt % 3 ){

				case CC_mode:
					ElMode = ( ElModeTypeDef ) CCMode;
					break;

				case CP_mode:
					ElMode = ( ElModeTypeDef ) CPMode;
					break;

				case CR_mode:
					ElMode = ( ElModeTypeDef ) CRMode;
					break;

				default:
					break;
			}

			// Select chosen operation mode
			if ( buttonPressed_f ){

				// Clear button flag
				buttonPressed_f = false;

				// Change operation mode
				menuState = ElMode.mode;

				menuFirstEntry = true;
			}
		}



		/*
		 * 	CONSTANT CURRENT FLOW
		 */
		else if ( menuState == CC_menu ){

			// Exit constant current mode
			if ( buttonTimeoutTime >= BUTTON_TIMEOUT ){

				// Clear bunch of variables and returns to main menu
				ReturnToMainMenu();
			}

			// ---- Constant current mode ---
			else{

				// Set reference current
				setPoint = GetReference(&RotaryEncoder, &CCMode);

				// Set current
				ElHealth = SetCurrent( setPoint );
			}
		}




		/*
		 * 	CONSTANT POWER FLOW
		 */
		else if ( menuState == CP_menu ){

			// Exit constant current mode
			if ( buttonTimeoutTime >= BUTTON_TIMEOUT ){

				// Clear bunch of variables and returns to main menu
				ReturnToMainMenu();
			}

			// Constant power mode
			else{

				// Set maximum power, as function of VDC
				CPMode.maximum = GetVoltage();

				// Set reference power
				setPoint = GetReference(&RotaryEncoder, &CPMode);

				// Set power
				ElHealth = SetPower( setPoint );
			}
		}



		/*
		 * 	CONSTANT RESISTANCE FLOW
		 */
		else if ( menuState == CR_menu ){

			// Exit constant resistance mode
			if ( buttonTimeoutTime >= BUTTON_TIMEOUT ){

				// Clear bunch of variables and returns to main menu
				ReturnToMainMenu();
			}

			// Constant resistance mode
			else{

				// Get reference resistance
				setPoint = GetReference(&RotaryEncoder, &CRMode);

				// Set resistance
				ElHealth = SetResistance( setPoint );
			}
		}



		/*
		 * 	Electronic load display and LEDs control
		 *
		 */

		// Menu mode display
		DisplayMenuMode( &ElMode );

		// LEDs control
		LedsMenuMode();



		/*
		 * 	Rotary encoder checking
		 *
		 * 	Period: 50 ms	( 20 Hz )
		 */
		if ( RETim_f ){

			// Clear flag
			RETim_f = false;

			// Check rotary encoder
			RotaryEncoderCheck(&RotaryEncoder);

			// Button timeout time increment
			if ( menuState != MAIN_menu  && ( !( BUTTON_PORT -> IDR & ( 1 << BUTTON_bp ) )) && !menuFirstEntry ){
				buttonTimeoutTime += ENCODER_TIMER_TIME_s;
			}
			else{
				buttonTimeoutTime = 0.0f;
			}


			// Check RE activeness
			if ( RotaryEncoder.cnt_diff ){
				displayRefreshTime = 0.0f;
			}

			// Display refresh time increment
			if ( menuState != MAIN_menu ){
				displayRefreshTime += ENCODER_TIMER_TIME_s;
			}
			else{
				displayRefreshTime = 0.0f;
			}



			/*
			 * 	BANG - BANG regulator
			 *
			 * 	Only regulate if rotary encoder is non active
			 */
		#ifdef BANG_BANG_REG_EN

			if ( !RotaryEncoder.active && setPoint != 0.0f ){

				// Positive error
				if ( GetCurrent() - setPoint > CUR_tol ){
					SetCurRefDuty( GetCurRefDuty() - 1ul );
				}

				// Negative error
				else if (( GetCurrent() - setPoint ) < -CUR_tol ){
					SetCurRefDuty( GetCurRefDuty() + 1ul );
				}
			}
		#endif

		}


		/*
		 * 	Seven segment display refreshing
		 *
		 * 	Period: 1ms ( 1 kHz )
		 */
		if ( DisplayTim_f ){

			// Clear display timer flag
			DisplayTim_f = false;

			// Display string in main menu only
			if ( menuState == MAIN_menu ){
				DisplayPrintStr(ElMode.display_chars, DisplayDigit);
			}

			// Display number inside operation modes
			else{
				DisplayPrintNum(DisplayNumber, DisplayDigit, displayDecPoint);
			}

			// Increment display digit
			if ( DisplayDigit <= 2 ){
				DisplayDigit++;
			}
			else{
				DisplayDigit = 0u;
			}

			// Sample current and voltage
			ADCStarConversion();
		}
	}
}



// Display timer overflow
void TIM3_IRQHandler(void){

	// Set display timer flag
	DisplayTim_f = true;

	// Clear interrupt flag
	TIM3 -> SR &= ~ TIM_SR_UIF;
}


// Encoder checking timer overflow
void TIM14_IRQHandler(void){

	// RE timer overflow flag
	RETim_f = true;

	// Clear interrupt flag
	TIM14 -> SR &= ~ TIM_SR_UIF;
}




// Button interrupt
void EXTI2_3_IRQHandler(void){

	// Button pressed flag
	buttonPressed_f = true;

	if ( menuState != MAIN_menu )
		menuFirstEntry = false;


	// Clear interrupt flag
	EXTI -> PR |= ( 1 << BUTTON_bp );
}



/*
 * 	Display in individual modes
 */
void DisplayMenuMode(ElModeTypeDef *mode){

	// Show reference value when rotating
	if ( RotaryEncoder.active ){

		// Clear refresh time
		displayRefreshTime = 0.0f;

		uint16_t d = 0u;

		// Display reference value
		// Mili mode for CC
		if ( mode -> mode == CC_mode ){

			// Hackish -> Dividing float number with 0.01 results in x.99999 something therefore compensating with 0.00001f
			d = (( uint16_t) ( setPoint * 10000u )) % 10;
			if( d )
				DisplayNumber = ( uint16_t ) (( setPoint + 0.00001f ) * 10000u );
			else
				DisplayNumber = ( uint16_t ) ( setPoint * 10000u );

			if ( setPoint == mode -> maximum )	displayDecPoint = false;
			else								displayDecPoint = true;
		}
		else
			DisplayNumber = ( uint16_t ) ( setPoint * 10u );
	}

	// Show actual value when stop rotating
	else if ( displayRefreshTime >= DISPLAY_REFRESH_TIMEOUT ){

		// Clear time
		displayRefreshTime = 0.0f;

#ifndef VOL_CAL_MEAS_EN

		// Mili mode for CC
		if ( mode -> mode == CC_mode ){
			DisplayNumber = ( uint16_t ) ( ( mode -> actValue )() * 10000u );

			if ( ( mode -> actValue )() >= mode->maximum )	displayDecPoint = false;
			else											displayDecPoint = true;
		}
		else{
			DisplayNumber = ( uint16_t ) ( ( mode -> actValue )() * 10u  );
		}

// Voltage calibration
#else
		// Display actual voltage value
		DisplayNumber = ( uint16_t ) ( GetVoltage() * 100u );
#endif
	}
}


// Returns to main menu
void ReturnToMainMenu(void){

	// Clear button timeout
	buttonTimeoutTime = 0.0f;

	// Clear reference
	setPoint = ClearReference();

	// Leave menu
	menuState = MAIN_menu;

	// Clear button flag
	buttonPressed_f = false;

	// Clear encoder ticks
	// For starting at CC in main menu
	TIM1 -> CNT = 0ul;
}

// Indication LEDs
void LedsMenuMode(void){

	// LEDs control
	if ( ElHealth == EL_OK ){
		switch ( menuState ){
			case MAIN_menu:
				LedsOff();
				break;

			case CC_menu:
				GpioPinOn(LED_PORT, LED_CC_bp);
				GpioPinOn(LED_PORT, LED_RANGE_bp);
				break;

			case CP_menu:
				GpioPinOn(LED_PORT, LED_CP_bp);
				break;

			case CR_menu:
				GpioPinOn(LED_PORT, LED_CR_bp);
				break;

			default:
				break;
		}
	}
	else{
		if ( RETim_f ){
			switch ( menuState ){
				case MAIN_menu:
					LedsOff();
					break;

				case CC_menu:
					GpioPinToggle(LED_PORT, LED_CC_bp);
					GpioPinOff(LED_PORT, LED_RANGE_bp);
					break;

				case CP_menu:
					GpioPinToggle(LED_PORT, LED_CP_bp);
					break;

				case CR_menu:
					GpioPinToggle(LED_PORT, LED_CR_bp);
					break;

				default:
					break;
			}
		}
	}
}
